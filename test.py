# -*- coding: utf-8 -*-
"""013

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19pP4rgQJdiStSENB_lEJmlbAWuLES0Ps
"""

# lets import all the Basic Libraries
from collections import defaultdict
from surprise.model_selection import cross_validate
from surprise import KNNWithMeans
from surprise import Dataset, Reader
import numpy as np
import pandas as pd

# Lets Read the Movies Dataset
movies = pd.read_csv('/home/dhruvil/MR_Project/userbased/movies.csv')

# Lets Read the Ratings Dataset
# ratings = pd.read_csv('/home/dhruvil/MR_Project/userbased/user_ratings.csv')

# Removing the Timestamp column from the Data, as the Surprise Library Accepts only three Columns
# ratings = ratings.drop(['timestamp'], axis=1)

# Now, we have to Create a CSV File for the new rating data, as the Surprise Library can only accept CSV Files as Input
# We will have to Specify the Header as None, as again the Surprise Library cannot take in Column Names
# We will have to set the Index also as False, Becaus ethe Surprise Library cannot Handle Indexes also.
# ratings.to_csv("/home/dhruvil/MR_Project/userbased/user_ratings.csv",
#                header=None,
#                index=False)

# lets take a Look at the Modified Dataset Before Feeding it to the Surprise Data Reader
x = pd.read_csv('/home/dhruvil/MR_Project/userbased/user_ratings.csv')

# Lets First Specify the File Path and Reader Parameters Required for Loading the Data
file_path = '/home/dhruvil/MR_Project/userbased/user_ratings.csv'
reader = Reader(line_format='user item rating', sep=',', rating_scale=(1, 5))

# Lets Load the Dataset into the Surprise Reader, We cannot read this Dataset, as this is a Surprise Object.
data = Dataset.load_from_file(file_path, reader=reader)

# Lets Build the Training Dataset
train = data.build_full_trainset()

# lets get the Number of Users and Items
print('Number of users in the Database :', train.n_users)
print('Number of items in the Database :', train.n_items)

# User Based collaborative Filtering.
my_sim_option = {'name': 'pearson', 'user_based': True}

# KNN model as backend
algo = KNNWithMeans(k=15, min_k=5,
                    sim_options=my_sim_option, verbose=True
                    )

# lets check the Accuracy of the Model

# Cross validation
results = cross_validate(algo=algo,
                         data=data,
                         measures=['RMSE'],
                         cv=5,
                         return_train_measures=True)

print(results['test_rmse'].mean())

# Lets Training the Model on our Dataset
algo.fit(train)

# lets Create a Dictionary to Map the Movie Id and Movie Names
movie_id_to_title_map = {}

for m_id, title in zip(movies['movieId'].values, movies['title'].values):
    movie_id_to_title_map[str(m_id)] = title

# lets check the Dictionary that we Created
movie_id_to_title_map

# Realtime prediction

# how much the user id - 1 would rate item id 31 ?
val = algo.predict(uid='1', iid='31')
print(movie_id_to_title_map[val[1]], val[3])

# Get Top n Predictions


def get_top_n(predictions, n=10, user_id=None):
    top_n = defaultdict(list)
    print ('inside get_top_n')
    for uid, iid, true_r, est, _ in predictions:
        if user_id == uid:
            print('inside if of user_id and uid 1')
            top_n[uid].append((iid, est))

    for uid, user_ratings in top_n.items():
        if user_id == uid:
            print('inside if of user_id and uid 2')
            user_ratings.sort(key=lambda x: x[1], reverse=True)
            top_n[uid] = user_ratings[:n]

    return top_n

testdata = train.build_anti_testset()
predictions = algo.test(testdata)
top_n = get_top_n(predictions, n=10, user_id='671')

# Lets Create a Function to Fetch all the Movies Watched by the Users
def PreviousMoviedUserWatched(user_df, user_id, item_map):
    user_df = user_df[user_df.iloc[:, 0] == user_id]
    for movie, rating in zip(user_df.iloc[:, 1].values, user_df.iloc[:, 2].values):
        print(item_map[str(movie)], rating)

# Lets Create a Function to Predict Movies to the Users based on the Movies Watched Previously


def UserPredictions(user_id, top_n, item_map):
    print("Predictions for User Id : ", user_id)
    user_ratings = top_n[user_id]
    for item_id, rating in user_ratings:
        print(item_map[item_id], " : ", rating)


print(PreviousMoviedUserWatched(x, 3, movie_id_to_title_map))

print(UserPredictions('671', top_n, movie_id_to_title_map))
